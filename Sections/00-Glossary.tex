\label{glossary}
\printglossaries 

\newglossaryentry{ICT}{
    name=ICT,
    description={Information and Communication Technology, a collective term for the electronic and computer systems which enable the \gls{internet} and the \gls{web} as well as stand-alone computerised devices and the \gls{internet of things}}
}

\newglossaryentry{sustainability}{
    name=sustainability,
    description={The ability of something to endure. Used in this dissertation to refer to the specific sustainability of human life and our supportive ecosystems on Earth}
}

\newglossaryentry{un goals}{
    name=UN Sustainable Development Goals,
    description={A set of 17 `goals' aimed at improving the \gls{sustainability} of humanity and the environment}
}

\newglossaryentry{sustainability ledger}{
    name=sustainability ledger,
    description={A metaphorical `balance sheet' of forces and actions which improve and/or worsen global \gls{sustainability}}
}

\newglossaryentry{sustainable computing}{
    name=sustainable computing,
    description={One of the names given to the intersection of the disciplines of \gls{sustainability} and \gls{computing}}
}

\newglossaryentry{computing sustainability}{
    name=computing sustainability,
    description={One of the names given to the intersection of the disciplines of \gls{sustainability} and \gls{computing}}
}

\newglossaryentry{computing and sustainability}{
    name=computing and sustainability,
    description={One of the names given to the intersection of the disciplines of \gls{sustainability} and \gls{computing}}
}

\newglossaryentry{green computing}{
    name=green computing,
    description={One of the names given to the intersection of the disciplines of \gls{sustainability} and \gls{computing}}
}

\newglossaryentry{distributed system}{
    name=distributed system,
    description={A computer system comprising more than one separate software or hardware node which communicate over a network}
}

\newglossaryentry{client}{
    name=client,
    description={A role in a \gls{distributed system} which sends network requests or messages to a \gls{server}}
}

\newglossaryentry{server}{
    name=server,
    description={A role in a \gls{distributed system} which receives and responds to network requests or messages from a \gls{client}}
}

\newglossaryentry{client-server}{
    name=client-server,
    description={A \gls{distributed system} in which computing elements have one of two roles: \gls{client} or \gls{server}}
}

\newglossaryentry{internet}{
    name=internet,
    description={A massive \gls{distributed system} which enables a wide range of services including email, social media, digital telephony, and the \gls{web}}
}

\newglossaryentry{web}{
    name=World-Wide Web,
    description={A distributed information system enabled by the \gls{internet} and accessed using a \gls{web browser}}
}

\newglossaryentry{web browser}{
    name=web browser,
    description={Software which enables users to access (also known as \emph{browse} or \emph{surf}) the information available on the \gls{web}}
}

\newglossaryentry{internet of things}{
    name=internet of things,
    description={The addition of sensors and other non-interactive devices to the internet to gather, interpret and transfer information as well as operate internet-connected equipment}
}

\newglossaryentry{the cloud}{
    name=the cloud,
    description={An abstraction model which treats multiple processing and data storage systems, typically located in large \gls{datacenter}s, as a single bank of assignable resources}
}

\newglossaryentry{cloud computing}{
    name=cloud computing,
    description={Any software and data systems which use resources in \gls{the cloud}}
}

\newglossaryentry{datacenter}{
    name=datacenter,
    description={A single building or collection of buildings providing shared support for a large amount of computing resources}
}

\newglossaryentry{dark web}{
    name=dark web,
    description={Information and services which are accessed using web technology but not listed in search data or linked from public pages. This makes such information largely invisible to general web users}
}

\newglossaryentry{intranet}{
    name=intranet,
    description={A section of the \gls{web} protected behind a login or other security approach and therefore inaccessible to external web browsers}
}

\newglossaryentry{client-side processing}{
    name=client-side processing,
    description={Code which executes on a \gls{client} device, rather than requiring a request to a \gls{server}}
}

\newglossaryentry{server-side processing}{
    name=server-side processing,
    description={Code which executes on a \gls{server}, typically in response to a request or message from a \gls{client} device}
}

\newglossaryentry{http}{
    name=HTTP,
    description={Hypertext Transfer Protocol, the basic protocol used to transfer requests ans responses between web browsers and web servers}
}

\newglossaryentry{https}{
    name=HTTPS,
    description={Hypertext Transfer Protocol Secure, an extension of the \gls{http} protocol in which requests and responses are encrypted}
}

\newglossaryentry{global warming}{
    name=global warming,
    description={Also known as 'climate change'. An observed increase in global average temperature over time}
}

\newglossaryentry{PUE}{
    name=power usage effectiveness,
    description={(PUE) An indication of the proportion of consumed energy used above that needed for the desired work}
}

\newglossaryentry{greenhouse gases}{
    name=greenhouse gases,
    description={A range of gases, including carbon dioxide and methane, which contribute to the \gls{greenhouse effect} when released into the atmosphere}
}

\newglossaryentry{greenhouse effect}{
    name=greenhouse effect,
    description={A process in which infra-red radiation is reflected back to a planet surface by the composition of the atmosphere rather than escaping into space. This capturing of heat energy leads to an overall increase in temperature}
}

\newglossaryentry{programming language}{
    name=programming language,
    description={A language used to instruct computing devices on what to do and how to do it. programming languages are usually textual but may also be graphical (e.g. Scratch\footnote{\url{https://scratch.mit.edu/}}) or symbolic (e.g. APL \citep{Falkoff1978})}
}

\newglossaryentry{web application}{
    name=web application,
    description={A software application which makes use of the \gls{web}. Web applications are typically distributed systems making use of one or more servers as well as web browsers}
}

\newglossaryentry{artificial intelligence}{
    name=artificial intelligence,
    description={The application of software and data systems to process information and reason in a manner based on living intelligence. Machine learning based on neural networks is an approach to achieve artificial intelligence}
}

\newglossaryentry{zombie}{
    name=zombie,
    description={In this context a zombie is a slang term for a computer system or application which continues operation even though it is no longer used by humans or other computer systems}
}

\newglossaryentry{upgrading}{
    name=upgrading,
    description={A strategy for improving the performance or operating costs of a computer system by replacing computing hardware with newer, more efficient, components}
}

\newglossaryentry{consolidating}{
    name=consolidating,
    description={A strategy for improving the operating costs of a computer system by sharing computing hardware between multiple systems}
}

\newglossaryentry{virtualisation}{
    name=virtualisation,
    description={A strategy for consolidating computer systems by running multiple \gls{virtual machine}s under the control of a \gls{hypervisor}}
}

\newglossaryentry{virtual machine}{
    name=virtual machine,
    description={An installation of an \gls{operating system} and applications running alongside other virtual machines under the control of a \gls{hypervisor}}
}

\newglossaryentry{hypervisor}{
    name=hypervisor,
    description={A form of \gls{operating system} which acts to manage access to the \gls{bare metal} of a computing system from multiple \gls{virtual machine}s}
}

\newglossaryentry{operating system}{
    name=operating system,
    description={A software system which provides services to applications, isolating them from the specifics of the underlying computing hardware. Current common operating systems include Windows, MacOS, and Linux}
}

\newglossaryentry{containerisation}{
    name=containerisation,
    description={An alternative to \gls{virtualisation} in which multiple isolated software systems can share aspects of a single underlying operating system. Containerised applications are typically smaller than virtualised applications because they do not need to duplicate existing operating system features}
}

\newglossaryentry{embedded system}{
    name=embedded system,
    description={A software system is described as `embedded' when it is tied to, and often developed alongside, specific computer hardware. Embedded systems often run on \gls{bare metal} without the need for an \gls{operating system}, or with a custom or \gls{real time} operating system}
}

\newglossaryentry{real time}{
    name=real time,
    description={A term used to describe software optimised for immediate response to events and stimuli. Common operating systems such as Windows or Linux are not classed as `real time' as they use process scheduling algorithms which can cause delays or interruptions to application software}
}

\newglossaryentry{bare metal}{
    name=bare metal,
    description={A term used when software runs on real rather than \gls{virtualised} computer hardware. In \gls{embedded system}s, the term `bare metal' is also used when software runs without the need for an \gls{operating system}}
}

\newglossaryentry{virtualised}{
    name=virtualised,
    description={A term used when a computer system executes in a \gls{virtual machine} rather than on \gls{bare metal} hardware}
}

\newglossaryentry{dynamic scaling}{
    name=dynamic scaling,
    description={The process of automatically starting up and shutting down virtual servers or application containers to meet increases or decreases in demand}
}

\newglossaryentry{template engine}{
    name=template engine,
    description={Also sometimes known as a \emph{template processor}, \emph{templating engine}, or \emph{templater}, this is a software application or library which combines a generic \gls{template} with dynamic data to create a composite output document}
}

\newglossaryentry{template language}{
    name=template language,
    description={The symbols, grammar and linguistic elements which are allowable in a \gls{template} for a particular \gls{template engine}. Typically a template language specifies the syntax for \gls{boilerplate} and \gls{placeholder}s within the template document}
}

\newglossaryentry{template processor}{
    name=template processor,
    description={Another name for a \gls{template engine}. For consistency, this thesis always uses the term \gls{template engine}}
}

\newglossaryentry{template}{
    name=template,
    description={A specification of an output document consisting of \gls{boilerplate} text and \gls{placeholder}s}
}

\newglossaryentry{boilerplate}{
    name=boilerplate,
    description={Blocks of predefined text in a \gls{template} which are included as-is in the output document when the template is rendered by a \gls{template engine}}
}

\newglossaryentry{placeholder}{
    name=placeholder,
    description={An indication in a \gls{template} of where, and potentially how, to include data provided when the template is rendered by a \gls{template engine}}
}

\newglossaryentry{computing}{
    name=computing,
    description={The term used by \citet{Denning1989} to include all aspects of the specification, architecture, design, construction, evaluation, maintenance, and management of solutions and products which use computer technology}
}

\newglossaryentry{software engineering}{
    name=software engineering,
    description={A field within \gls{computing} which applies engineering principles and computer programming expertise to develop, test, and maintain software applications}
}

\newglossaryentry{computer systems engineering}{
    name=computer systems engineering,
    description={A field within \gls{computing} which applies engineering principles and computer programming expertise to develop, test, and maintain computer systems}
}

\newglossaryentry{software development}{
    name=software development,
    description={A field within \gls{computing} which includes conceiving a goal, evaluating feasibility, analysing requirements, design, implementation, testing and release management}
}

\newglossaryentry{informatics}{
    name=informatics,
    description={A field within \gls{computing} concerned with representation and transformation of information}
}

\newglossaryentry{data science}{
    name=data science,
    description={A field within \gls{computing} concerned with representation, storage and manipulation of data}
}

\newglossaryentry{information science}{
    name=information science,
    description={A field within \gls{computing} concerned with analysis, collection, classification, manipulation, storage, retrieval, movement, dissemination, and protection of information}
}

\newglossaryentry{computer science}{
    name=computer science,
    description={A field within \gls{computing} which includes both theoretical disciplines such as algorithms, theory of computation, and information theory, and applied disciplines such as the design and implementation of hardware and software}
}

\newglossaryentry{performance}{
    name=performance,
    description={In \gls{computing}, performance is usually used to refer to speed. In software, performance relates to the speed of the software in performing a given task. In hardware, performance is usually related to the speed at which the hardware can operate. Performance is inversely related to the time taken to perform a task}
}

\newglossaryentry{speed}{
    name=speed,
    description={In \gls{computing}, speed is often used interchangeably with performance. Speed is conceptually easy to measure for tasks that have a defined start and end - a faster task completes in less time. Speed is less easy to measure for services or applications that run until manually stopped}
}

\newglossaryentry{efficiency}{
    name=efficiency,
    description={In \gls{computing}, efficiency is commonly used in the sense that an efficient system is one which achieves an objective using minimal resources. The resources in question may include such things as time, energy, disk space, computer memory or any other scarce or costly resource. Where a specific resource is considered, the term can add a modifier, for example energy-efficiency or memory-efficiency}
}

\newglossaryentry{energy use}{
    name=energy use,
    description={A measure of the amount of energy used to achieve an objective. In \gls{computing}, energy use typically refers to the amount of electrical energy required for specific computing hardware to run software to complete the aims of the software. See also \gls{power consumption}}
}

\newglossaryentry{power consumption}{
    name=power consumption,
    description={A measure of the amount of energy used to achieve an objective. In \gls{computing}, power consumption typically refers to the amount of power required at any time for specific computing hardware to operate a long-running software system. See also \gls{energy use}}
}

\newglossaryentry{side-effects}{
    name=side-effects,
    description={In a template language, a side-effect is anything which happens as a result of a template placeholder expression other than the production of text for the output document. Examples might be modifying the operation of other placeholder expressions, controlling the operation of the template engine as a whole, or executing code on the underlying computer system}
}

\newglossaryentry{functional requirements}{
    name=functional requirements,
    description={Requirements that a system must meet in order to be considered fit for purpose. Functional requirements can usually be phrased in a way which allows for a yes/no or pass/fail answer}
}

\newglossaryentry{non-functional requirements}{
    name=non-functional requirements,
    description={Aims that a system should meet in order to be considered fit for purpose. Non-functional requirements are often vague or aspirational and can be difficult to measure}
}

\newglossaryentry{soft requirements}{
    name=soft requirements,
    description={An alternative name for \gls{non-functional requirements}.}
}

\newglossaryentry{design pattern}{
    name=design pattern,
    description={An description of a common software design approach. Eaxh design pattern is phrased in terms of four elements: the pattern name, the problem it addresses, the solution it provides, and the consequences of adopting that solution \citep{Gamma1994}}
}

\newglossaryentry{strategy design pattern}{
    name=strategy pattern,
    description={A software \gls{design pattern} in which alternate implementations of a solution can be treated interchangeably by sharing a common abstraction}
}

\newglossaryentry{lazy evaluation}{
    name=lazy evaluation,
    description={A software technique in which calculation or processing of derived values is deferred until the values are used. The main advantage of this approach is that derived values never need to be calculated if they are never used. This can be particularly significant if a calculation involves a relatively slow process such as requesting information from a remote system. The opposite approach to lazy evaluation is \gls{eager evaluation}}
}

\newglossaryentry{eager evaluation}{
    name=eager evaluation,
    description={A software technique in which calculation or processing of derived values is performed as soon as the input values are available. The main advantage of this approach is that derived values are already available when required, which can improve the responsiveness of a software application. The opposite approach to eager evaluation is \gls{lazy evaluation}}
}

\newglossaryentry{continuous integration}{
    name=continuous integration,
    description={A software technique in which software consisting of multiple collaborating parts is assembled and tested by an automated process. This process is performed whenever any of the component parts of the system are changed, to ensure that changes to individual parts do not affect the behaviour or performance of the larger system}
}

\newglossaryentry{embedded}{
    name=embedded,
    description={A software system is described as `embedded' when it is designed for a specific hardware configuration. Often the hardware and software for an embedded system are designed together}
}

\newglossaryentry{cross-compile}{
    name=cross-compile,
    description={Cross-compilation is a software development technique involving creating software on one machine, typically one set up as a development workstation, and using software tools to generate code which will run on a different device. Cross-compilation is commonly done when developing software for \gls{embedded} systems}
}

\newglossaryentry{JavaBeans}{
    name=JavaBeans,
    description={A feature of the Java \gls{programming language} that allows some object methods to be accessed as if they are fields. To be accessible as a JavaBean, a class must have a zero-argument constructor and methods with specific name patterns. See \url{https://docs.oracle.com/javase/8/docs/technotes/guides/beans/index.html}}
}

\newglossaryentry{classpath}{
    name=classpath,
    description={A classpath is an path-style environment variable containing a sequence of places for the Java Virtual Machine to look for class files when loading an application. The entries in the classpath may be directories in a file system, individual class files, or \emph{JAR} archive files}
}

\newglossaryentry{black box}{
    name=black box,
    description={A black box component is one which is used in whole and without the ability to modify the way it works. Black box component reuse is a process in which a component is reused without modification}
}

\newglossaryentry{white box}{
    name=white box,
    description={A white box component is one which is provided in the form of source code which may be modified or used in part. White box component reuse is a process in which a component is used as a source of code for modification.}
}
