\chapter{Literature and Research Objectives}
\label{chapter:questions}

This chapter explores the terminology, literature and prior work which informed the research described in this dissertation, then proceeds to establish a research gap and discuss the research objectives which led to the research described in later chapters.

\section{A Note on Terminology}
\label{section:terminology}

Information and Computer Technology (ICT) is a relatively new and continually developing field, in which the terminology has not fully stabilised. This section provides a sense of the competing terminologies in play in the literature and introduces key terminology which will be used throughout this dissertation.

ICT is also a wide field. Taking guidance from \citet{Denning1989}, this dissertation uses the umbrella term \emph{Computing} to include all aspects of the specification, architecture, design, construction, evaluation, maintenance, and management of solutions and products which use computer technology. In academic terms this includes a range of sub-disciplines such as \emph{Software Engineering}, \emph{Software Development}, \emph{Informatics}, \emph{Information Science}, \emph{Information Systems}, \emph{Computer Science} and other areas of research as appropriate. Discussion continues as to whether some of these sub-disciplines would benefit from being merged \citep{Fitzgerald2024}. Sustainability is also a wide field, spanning all seventeen of the UN Sustainability goals \citep{UnitedNations2015}. The research discussed in this dissertation sits in the area in which the two broad concepts overlap and is mapped to the UN sustainability goals in \autoref{section:un goals}.

The overlap between computing and sustainability is known by many names such as \emph{Sustainable Computing}, \emph{Computing Sustainability}, \emph{Computing and Sustainability}, \emph{Green Computing}, and so on. However, these names are imprecise, and convey different meanings to different readers. \textcite{Penzenstadler2013} divided such research into two sub-areas: `Software Engineering \emph{For} Sustainability', and `Sustainability \emph{Of} Software Engineering'. Although \citeauthor{Penzenstadler2013}'s research was in the specific area of software engineering, the distinction holds, and later writing by several authors uses the same formulation but with other sub-disciplines such as `software', or the more general `computing'.

A major contributor to the environmental impact of computing systems is the consumption of energy, specifically electricity to power electrical and electronic systems. Other forms of energy are also used in the operation of computing systems, for example for cooling or transport, but this research concentrates on electrical energy usage. Literature in this field uses a mixture of terminology and measurement units. In experimental literature where energy consumption is measured or estimated, the units are usually \emph{Watts} (for power) and \emph{Joules} (for energy), but some writing on this topic uses \emph{Watt-hours}, \emph{Kilowatt-hours}, or \emph{BTU} (British Thermal Units) for energy values. One Joule is defined as one Watt for one Second, so one Watt-hour is equivalent to 3,600 Joules and one Kilowatt-hour is equivalent to 3,600,000 Joules. One BTU is roughly equivalent to 1055 Joules. In more general discussions in the literature, the terms \emph{power} (as in \emph{power consumption}) and \emph{energy} (as in \emph{energy use}) are often used largely interchangeably.

Another key terminological distinction is between the closely-related concepts of \emph{performance}, \emph{efficiency}, and \emph{energy use}/\emph{power consumption}. Performance in computing literature is typically used in a sense equivalent to speed. This meaning is clear when discussing a software program which starts then runs uninterrupted until completion. However, the meaning of performance is not so clear when discussing a service application which runs `forever' (or at least until explicitly terminated) but waits, for example for user input or for data to arrive, then processes, stores, or forwards that input. In such cases performance may mean speed, but only during certain operations, or it may have a meaning closer to responsiveness or throughput. In discussions of algorithms, efficiency is typically used in a sense largely equivalent to performance. Code is more `efficient' if it does its job in less time. This becomes more complex, however when data is involved, as some algorithms may be faster or slower for some sizes or classes of data. With the increase in interest in energy usage, a need has developed for an energy-related efficiency measure in which code is more efficient if it does its job using less energy, known by various terms such as the generally popular \emph{energy efficiency} but also \emph{power efficiency} \citep{Manner2023} \citep{Chien2021}, \emph{green efficiency} \citep{Salam2018}, or \emph{carbon efficiency} \citep{Dorkal2023}. In the energy domain there is no direct equivalent to performance or speed, although some writers have explored using metaphorical terms such as \emph{leanness} \citep{Wirth1995} or \emph{frugality} \citep{Gancarz2023b} or \emph{responsible consumption} \citep{Becker2015} for software which uses less resources generally. The popular terms `power consumption' and `energy use' are equivalent to the inverse of (energy) performance. \citet{Garcia2006} attempted to encourage \enquote{a consistent terminology for software measurement}, for example by recommending the use of the term `measurement' rather than the potentially-confusing `metric' but, on the whole, the publications reviewed for this research continue to use inconsistent and sometimes ambiguous terminology. 

In this dissertation, \emph{performance} and \emph{speed} are used for the time domain and \emph{energy use} and \emph{power consumption} are used for the energy domain. Where \emph{efficiency} is used in a potentially ambiguous context it will be prefixed with \emph{energy-} or \emph{time-}.

The field of computing has its own set of terminology, some of which conflicts with usage in other disciplines. The word \emph{sustainability}, for example, has traditionally been used in software engineering in a sense equivalent to longevity or maintainability. In that sense, a computing system would be more sustainable if it could continue to do its job for a longer time. Likewise, the word \emph{environment} is commonly used to refer to a combination of the computer hardware platform on which the software is to be run, and any external settings or configurations which affect the operation of the software. Software development is an abstract field correspondingly rich with metaphors, such as the use of \emph{component} for a fragment of software which is, or could be, re-used in a different context. Some software development contexts provide a \emph{library} of such components, which are then described as \emph{library code} or just \emph{libraries} Sometimes a collection of components or library code will be grouped into an Application Programming Interface, commonly referred to as an \emph{API}. Some such software components, libraries or APIs are available for free or included with software development tools. Others, sometimes referred to as \emph{Commercial Off The Shelf} or \emph{COTS} software, are commercial products.

This dissertation will generally use the term \emph{component} for any kind of reusable software, regardless of whether it is available separately or forms part of a library or API and regardless of its cost.

Note that when discussing literature it is sometimes necessary to echo the terminology used by the authors.

\section{Literature and Related Research}
\label{section:literature}

The following subsections provide an overview of related literature. Starting from the big picture of global sustainability, each subsection narrows the focus, leading to clarification of a research gap in \autoref{literature:gap} and enumeration of specific research objectives in \autoref{section:research objectives}.

\subsection{The Global Importance of Sustainability}
\label{literature:importance}

Sustainability is one of the defining topics of the age \citep{Brundtland1987}. Where once the human race generally assumed that the Earth's resources were inexhaustible, we are now aware of the existence of \emph{Planetary boundaries} \citep{Steffen2015} and the impact that human activity and development is having on the environment. \citet{Pierrehumbert2019} analysed the contribution of human activity to global warming and the potential effectiveness of large scale mitigation strategies such as carbon storage and `albedo hacking' and concluded that \enquote{There is no Plan B for dealing with the climate crisis}. The only feasible solution is to immediately and significantly reduce greenhouse gas production. This is not a simple process, however. \citet{Beattie2010} examined psychological aspects of why \enquote{saving the planet} is hard, and \citet{Goodland2002} explored the tangled human, social, economic and environmental aspects of sustainability.

\subsection{What Sustainability Means for Computing}
\label{literature:computing}

Sustainability is a complex topic with multiple dimensions \citep{UnitedNations2015}. While there has been a lot of writing on computing and sustainability, much of it has been concerned with aspects such as social inequality and pollution \citep{Hilty2011a} rather than energy use and greenhouse gas emissions. The exact impact of computing on greenhouse gas emission is difficult to quantify. Popular media and literature are filled with wild claims. \citet{Freitag2021} summarised peer-reviewed research in this area and concluded that the contribution of ICT to greenhouse emissions is probably between between 2.1 and 3.9\% of the global output. This is more than the entire output of the aviation industry \citep{EESI2022}. \citet{Knowles2022} highlighted an attitude of `digital exceptionalism' which assumes that computing is the general solution to environmental problems. This attitude is evident in the large body of \emph{Computing for Sustainability} research which presents computing solutions without considering their wider impact. \citet{Coroama2009} made the case that environmental benefits and costs should both be considered in such research and recommended \enquote{decomposing the ICT monolith} to examine the energy use and energy benefits of its constituent parts. \citet{Tocze2022a} introduced the concept of \emph{unsustainability patterns}, such as unsolicited marketing (`spam') and excessive data transfer from `Internet of Things' (IoT) devices, which consume resources for little or no overall value. The authors also observed that the users of computing systems are often uninformed or powerless when it comes to choosing more sustainable ICT services. \citet{Koomey2009} stated that \enquote{far too little attention has been paid to the true total costs for data center facilities}. Other researchers also pointed out that the response to system changes or improvements is not always beneficial. A change such as an improvement in speed, efficiency, or usability can trigger increased use of the system (through so called \emph{rebound effects}) which can negate or even overshadow the original improvement \citep{Hilty2006} \citep{Gossart2015} \citep{Adelmeyer2017}.

The fragmentation of the computing discipline noted in \autoref{section:terminology} has led to disjointed recognition and adoption of sustainability across the field. \citet{Naumann2008} proposed `sustainability informatics' as \enquote{a new subfield of applied informatics} while admitting that some aspects of sustainable development had previously been included under the term `environmental informatics'. Two years later, \citet{Tilson2010} described digital infrastructures and their sustainability as \enquote{the missing IS research agenda}.  \citet{Penzenstadler2014} presented sustainability as an additional \emph{nonfunctional requirement} in addition to safety and security and considered second- and third-order effects of sustainability initiatives, including rebound effects. Meanwhile, \citet{Venters2014} characterised software sustainability as a \enquote{tower of babel} in which:

\begin{displayquote}
the term software sustainability is frequently used to embody vague, diverse and contradictory ideas that are neither sound nor novel \citep[p. 5]{Venters2014}\end{displayquote}

\citet{Becker2015} produced the much-cited \enquote{Karlskrona Manifesto for Sustainability Design} consisting of nine key principles and commitments intended to \enquote{redefine the narrative on sustainability and the role it plays in our profession}.
\citet{Manotas2016} performed a study of practitioners' perspectives on `green' software engineering and gathered responses such as:

\begin{displayquote}
Our main concern is marketshare and that means user experience is a priority. We can be more efficient to try to cut costs, but since we don’t charge by energy used this doesn’t make us more attractive to users. So we tend to focus on other things like performance or reliability. \citep[p.241]{Manotas2016}
\end{displayquote}

In \citeyear{Pinto2017a}, \citeauthor{Pinto2017a} proposed `energy efficiency' as \enquote{a new concern for application software developers} and \citet{Jagroep2017} called for an `awakening' of awareness on energy consumption in software engineering. \citet{Fonseca2019} produced a \enquote{manifesto for energy-aware software}, lamenting that:

\begin{displayquote}
as software engineers, we were never taught to consider, much less manage, the energy consumption of the software systems we created. \citep[p.79]{Fonseca2019}
\end{displayquote}

Research in this area continues. \citet{Venters2021} revisited the earlier \enquote{tower of babel} characterisation and highlighted the need to:
\begin{displayquote}
take into account the direct and indirect negative impacts on different dimensions of sustainability that result from the development, deployment, and continued use of the software system \citep[p. 2]{Venters2021}
\end{displayquote}

In addition to research which explores and documents the current state of software and sustainability, some literature also considers potential solutions. \citet{Widdicks2018} suggests \enquote{Undesigning the Internet}, an approach which reduces personal usage of computing resources by temporarily withdrawing from connected activities. While this can potentially have environmental benefits, it also suffers from the general powerlessness and lack of control reported by \citet{Tocze2022a}. Background processes and systems consume energy regardless of whether a particular user is accessing the service. Emails and social media content continue to mount up even while you are disconnected. A different approach to addressing sustainability of software is to provide increased information and choice to end users. While still not common for desktop or server software, there have been several attempts to promote `energy labels' for mobile applications \citep{Wilke2012} \citep{Baek2018} \citep{Behrouz2015} following media coverage of mobile applications which required excessive energy and drained phone batteries.

\subsection{Literature Reviews and Summaries}
\label{literature:summaries}

Other researchers have also reviewed and summarised literature in this area, many of whom have followed formal guidelines such as those provided by \citet{Kitchenham2007}. \citet{Hilty2011} attempted an overview of sustainability and ICT, and noted the rise of emphasis on the environmental impact of computing systems following the Gartner report \emph{Green IT: a new industry shock wave} \citep{Mingay2007}. \citeauthor{Hilty2011} also highlighted the potential of \emph{rebound effects} illustrated by the continuing increase in ICT use and its energy consumption despite great increases in efficiency over the same period. \citet{Penzenstadler2012} compiled a systematic literature review which noted some of the terminology confusion mentioned in \autoref{section:terminology} but concluded that \enquote{currently, there is little research coverage on the different aspects of sustainability in software engineering}. However, \citeauthor{Penzenstadler2012}'s review was restricted to a narrow view of what constitutes `software engineering' and may have rejected literature positioned in other aspects of computing. This literature shows that there is a growing need for research into the environmental impact of software systems.

\citet{Calero2013} surveyed literature between 1992 and 2012 for `software sustainability measures' and observed an increase in literature over the period with the first mention of `software sustainability' identified in 2003. \citeauthor{Calero2013} took a broad view of sustainability, however, with only a passing discussion of energy use and no mention of the more modern concerns of greenhouse gasses and global warming. Meanwhile, \citet{Kern2013} also studied existing literature on quality aspects of `green' software and software engineering, but with an explicit emphasis on energy usage, energy measurement and energy saving. \citeauthor{Kern2013} also suggested a \emph{GREENSOFT} model to classify energy-related software engineering approaches. The comparison of these contemporary studies shows how a relatively small shift in emphasis and inclusion criteria can produce very different results.

\citet{Penzenstadler2014a} followed an earlier systematic review \citep{Penzenstadler2012} with a mapping study of \enquote{software engineering for sustainability} which found considerably more publications than their previous study and noted the formation of several research clusters in which authors regularly collaborate with or cite other cluster members. Later literature studies tended to observe \citet{Penzenstadler2013}'s distinction between \emph{of} and \emph{for} and explore more specific niches within one or the other. Examples of more specific literature surveys include sustainability requirements \citep{Chitchyan2016}, architecture \citep{Paradis2021}, tactics for improvement \citep{Balanza-Martinez2023}, and energy measurement methodology \citep{Hindle2016}. This period also witnessed a rapid growth in the use of smartphone `apps' and a concomitant increase in literature research on energy consumption and battery life in mobile devices such as \citet{Ahmad2015}, \citet{Moreira2020} and \citet{Schuler2023}. This literature highlights the breadth of the field and the increasing tendency to specialise by application niche or methodology.

More recent literature studies include \citet{Venters2023}, which surveyed the broad field of sustainable software engineering and considered future trends, and \citet{Lee2024} which explored \enquote{energy concerns} in software engineering and found them \enquote{taken into account in all phases of software development and operation}. This literature indicates the increasing desire for information about energy use in software engineering.

Considered as a whole, the literature studies above illustrate the importance of the field as well as a continued growth in interest and increased specialisation. Specific areas are examined in more detail in the following sections.

\subsection{Sustainability in Requirements and Architecture}
\label{literature:requirements}

In the classic software development life cycle (SDLC), requirements and architecture phases take place before system implementation, a natural point to consider sustainability issues. Formulating requirements for sustainability is challenging because, other than a few specific cases such as operational battery life, sustainability is a \emph{non-functional} requirement without clear guidelines or measurable acceptance criteria. The most compelling non-functional requirement is often monetary cost, so \citet{Gu2012} proposed codifying `green' strategies in financial terms and found it useful in some situations but not globally applicable. \citeauthor{Condori-Fernandez2018} (\citeyear{Condori-Fernandez2015}) and (\citeyear{Condori-Fernandez2018}) attempted to align sustainability requirements with other quality requirements and found some overlap with aspects such as modifiability, freedom from risk, and satisfaction. \citet{Bashroush2016} surveyed software architects about environmental impact and energy use and concluded that the sector lacks tool support, information, and prioritisation from stakeholders. However, as \citet{Penzenstadler2013a} pointed out, identifying stakeholders and their objectives is not always a simple task. \citet{Kazman2018} looked specifically at energy consumption as a quality attribute and investigated strategies for modelling and prototyping to reason about designing for better energy use, but this approach still depends on consideration and inclusion of appropriate energy targets during requirements gathering.

There have been several attempts to construct models and frameworks to aid in the inclusion of sustainability during the creation of software systems. \citet{Dick2010} proposed enhancements to the SDLC to include a sustainability journal and retrospectives. This research was later developed into the \emph{GREENSOFT} model which promoted \enquote{a cradle-to-grave product life cycle model for software products, sustainability metrics and criteria for software} \citep{Naumann2011}. The Sustainability Awareness Framework (\emph{SusAF}) is a framework based on Design Science Research (DSR) \citep{VomBrocke2020} which \enquote{provides interested stakeholders with a supported process for thinking about and expanding their anticipation of the possible sustainability effects of their IT products and services} \citep{Betz2024} and includes questions and discussion guidelines to provoke consideration of five dimensions of sustainability during the requirements process. \citet{Saputri2016} proposed a framework to \enquote{analyze the dimensions of sustainability and structure it into software requirements}. Their framework is based on questions for stakeholders and relies on quantifying and weighting answers.

These kinds of models and frameworks can be useful in adding structure to the consideration of sustainability issues when discussing system requirements and potentially during the architecture, design, development and operation of the system but they also have limitations. Any framework or model based primarily on discussions with stakeholders does not cope well with stakeholders who either do not know or do not care about the sustainability of the resulting system. Such models rely on the presence of `domain experts' \citep{Christel1992} who understand what is needed. This is probably true when it comes to the functional and non-functional requirements which describe the \emph{task} of the system but neither `domain experts' nor software developers are likely to fully understand the sustainability impact of their requirements choices \todo{citation}. 

Rather than include sustainability in the requirements elicitation phase of development, the Green Software Foundation (GSF) \citep{GreenSoftwareFioundation2024} offers six \enquote{key areas} [\autoref{gsf principles}]. The first four of these areas act as implicit, non-negotiable, requirements for every project and the final two as guidelines for how to achieve them.

\begin{table}[htbp]
    \centering
    \begin{tabular}{rll}
        1 & \textbf{Carbon Efficiency} & Emit the least amount of carbon possible. \\
        2 & \textbf{Energy Efficiency} & Use the least amount of energy possible. \\
        3 & \makecell[tl]{\textbf{Carbon Awareness}} & \makecell[tl]{Do more when the electricity is cleaner and \\ do less when the electricity is dirtier.} \\
        4 & \makecell[tl]{\textbf{Hardware Efficiency}} & \makecell[tl]{Use the least amount of embodied carbon \\ possible.} \\
        5 & \textbf{Measurement} & What you can't measure, you can't improve. \\
        6 & \makecell[tl]{\textbf{Climate Commitments}} & \makecell[tl]{Understand the exact mechanism of \\ carbon reduction.} 
    \end{tabular}
    \caption{GSF Key Areas (after \citet{GreenSoftwareFioundation2024})}
    \label{gsf principles}
\end{table}

Even when stakeholders do understand and prioritise the sustainability aspects of the system there also the further problem of a lack of information. Software architectures, designs, tools, and components do not come with sustainability ratings, so in many cases there is no way to judge whether any option will be `better' or `worse' from a sustainability perspective without implementing it. 

In cases where requirements include sustainability, these sustainability requirements then need to be incorporated into the architecture and design of the system. \citet{Ameller2012} interviewed a group of software architects about the inclusion of such non-functional requirements and found that non-functional requirements suffered from \enquote{terminological misunderstandings}, were often managed independently from other requirements, and were rarely validated to confirm appropriate implementation. \citet{LaToza2013} interviewed software developers and noted that \enquote{architectural decisions often become technology decisions, which are in turn influenced by both technical and social factors} but such decisions are vulnerable to the later discovery of incompatibilities which can require major re-work. \citet{Venters2017} also considered software sustainability as an aspect of architecture with particular emphasis on managing the different dimensions of sustainability from the Karlskrona Manifesto \citep{Becker2015}. \citet{Lago2019} explored the use of \emph{decision maps} to reason about the interactions and conflicts between different architectural requirements and found \enquote{much confusion} between long and short-term goals as well as difficulties associating their \emph{quality concerns} with measurable values.

Other literature related to sustainable requirements and architecture tends to address specific technological areas such as cloud computing \citep{Khomh2018} \citep{Chen2012}, virtual machines \citep{Marcu2011}, and re-engineering \citep{Jelschen2012}. For example, during the course of this research, the \emph{Well-Architected Framework} \citep{AmazonWellArchitected} promoted by Amazon Web Services was updated to include an explicit \enquote{sustainability pillar}. This indicates the importance of addressing holistic sustainability issues in the architecture of cloud computing systems as well as just minimising operational costs.

\subsection{Challenges of Sustainable Software}
\label{literature:challenges}

Architectural decisions notwithstanding, software is created by software developers, and the process of implementing sustainable software poses many challenges. \citet{Pang2016} investigated attitudes of software developers to software energy consumption and discovered that more than 80\% of the people surveyed did not take energy consumption into account when developing software. \citet{Pinto2014} examined the popular developer resource \emph{Stack Overflow}\footnote{\url{https://stackoverflow.com/}} for attitudes on software energy consumption and encountered both a wide diversity of questions and answers which were flawed or vague.

Software is developed in a wide variety of ways ranging from the rigid `cathedral' to the chaotic `bazaar' \citep{Raymond1999}; from secretive commercial applications to public participation \citep{Ballhausen2019}; from requirement-driven to agile \citep{Dick2013}; and in team sizes from a lone coder to organisations with thousands of employees \citep{Sawyer2004}. \citet{Naumann2015} attempted to synthesise a practice of \emph{green software engineering} from this broad field but ended with more questions than answers.

One of the major issues for green software development is the continually-evolving nature of software. Every change to a software system can potentially affect its sustainability and environmental impact. \citet{Betz2015} tackled this problem by introducing the concept of \emph{sustainability debt}, while \citet{Couto2020} took a similar but more specific approach with \emph{energy debt}. \citet{Ren2004} proposed a tool for change impact analysis of java programs. All such approaches, however, rely on being able to assess the sustainability or the energy usage of the system being developed \citep{Jagroep2016}. Software energy usage measurement is discussed in depth in \autoref{literature:methods}.

In the absence of effective direct energy measurement, developers typically resort to guidelines and \emph{rules of thumb} \citep{Aggarwal2015}. Examples of such techniques are \emph{design patterns} \citep{Gamma1994} and \emph{code smells} \citep{Fowler1999}. Both the sustainability impact of design patterns \citep{Sahin2012} \citep{Noureddine2015a} \citep{Litke2005}, their associated refactoring \citep{daSilva2010} \citep{Sahin2014}, and smells/leaks \citep{Gottschalk2012} \citep{Palomba2019} \citep{Pereira2020} \citep{Vetro2013} have been extensively explored in the literature. Design patterns and code smells are often positioned as aids to software maintainability, so \citet{Mancebo2021} investigated the relationship between maintainability and energy consumption and concluded that classic measures of software maintainability, such as cyclomatic complexity, did not correlate well with energy usage, but that, in general, software with more code tended to use more energy overall.

\subsection{Reuse: Commercial, Free, and Open Source Components}
\label{literature:components}

Modern software development commonly makes use of existing software, in the form of components, libraries, or APIs. Understanding the characteristics of such dependencies forms a key aspect of reasoning about the sustainability characteristics of the system as a whole. \citeauthor{Mileva2010} (\citeyear{Mileva2009}) and (\citeyear{Mileva2010}) investigated the popularity of libraries and APIs, \citet{Hejderup2018} developed a \emph{software ecosystem call graph} for dependency management and \citet{Bauer2012a} attempted to model API usage to inform decision-making. All of these approaches, however, only make sense for energy sustainability evaluation if the energy characteristics of the components are well understood. This is a separate area of research. For example, the Java `collections' classes, part of the standard Java library, have been comprehensively evaluated for energy consumption \citep{Hasan2016} \citep{Pereira2016} \citep{Pinto2016}.

\citet{Capra2012} concluded that the design of software systems, particularly the selection and use of frameworks and software libraries, can have a \enquote{significant impact on the energy efficiency of software applications}. The authors compared the total energy required to perform an operational scenario on two MIS (Management Information Systems) applications running on similar computer hardware and determined that one application required approximately twice the energy for the same task. They also observed that the relationship between performance and energy use was complex and non-linear, affected by factors such as the underlying hardware and operating system platform and the specifics of the evaluation scenario.

At the end of the 20th century there was a lot of research on software re-use and its benefits to productivity \citep{Lim1994} \citep{Basili1996}, and success factors \citep{Frakes1994} \citep{Kim1998}.  Initially, re-usable components were largely commercial products, known as \emph{Commercial Off The Shelf} (COTS). \citet{Boehm1999} considered the practicality of integrating COTS components, calling it \enquote{plug and pray?}. \citet{Lawlis2001} proposed a formal process for evaluating COTS software products, but \citet{Torchiano2004} pointed out a list of `overlooked' problems with integrating COTS components into an application including disagreements on terminology, missing or incomplete features, and a lack of standards.

This period also saw the rise of open source software, which upset the economics of COTS for everything except large applications or services \citep{Lerner2002}. Once people began to understand the motivation of open source developers \citep{Hertel2003} \citep{Lakhani2003}, it rapidly became the predominant method of code reuse \citep{Mockus2007} \citep{Haefliger2008} \citep{Sojer2010}.

Open source software is not without its risks, however. In 2016, thousands of software products broke when an angry software developer removed his code from a public repository \citep{Williams2016}. This raised a lot of questions about the prolific and largely unquestioning use of open source components \citep{Abdalkareem2017}, and provoked interest in tracking the composition of software through a software \emph{bill of materials} analogous to the list of parts for physical manufacturing \citep{Xia2023}, and a software component `fingerprint' technique known as \emph{bertillonage} \citep{Davies2013}.

\citet{Badampudi2016} conducted a systematic literature review on the decision-making process for software components, selecting between in-house, open source, COTS or outsourcing. They identified four key criteria: time (to implement once selected), cost (to purchase or subscribe), effort (to evaluate before selecting) and quality (of implementation, support, etc.). Aside from cost, which is often known at the start of the process, the other factors are initially unknown and will require effort to determine. This goes some way to explain why cost-free open source components are so often selected. However in cases where the choice is between multiple cost-free options, there are no remaining criteria which do not require at least some additional effort.

\subsection{Selecting Components and Libraries}
\label{literature:selection and comparison}

\citet{Hucka2018} conducted a literature review and survey to explore how scientists and engineers find and evaluate software. They discovered that developers use five key sources of information: general purpose web search; ask colleagues, look in social help sites such as \emph{StackOverflow}, search in public software project repository sites such as \emph{GitHub}, and look in scientific literature. \citet{LariosVargas2020} studied the challenge of selecting third-party libraries, found 26 separate potentially conflicting decision factors, and argued that \enquote{the lack of a systematic approach may lead software developers to choose libraries arbitrarily, without considering the consequences of their decisions}.

\citet{Milkman2009} explored psychological aspects of decision making in general and how it might be improved, while \citet{Nguyen2020} used collaborative filtering techniques to develop a system for recommending third-party libraries based on public repository data. \citet{delaMora2018a} used similar repository data to propose a `metrics-based' comparison of software libraries. Unfortunately, the public information used by these systems is limited to general metadata such as rating, popularity, and release frequency and provides no guidance on whether a library is more or less suitable for specific functional or non-functional requirements. \citet{Anwar2020} explored energy consumption as a factor in the choice of HTTP client libraries. They concluded that choice of library does make a difference to energy consumption, but as no suitable public data was available they needed to perform their own experiments to determine the energy consumption of each library.

\subsection{Experimental Methodology Literature}
\label{literature:methods}

Software has a rich history of performance measurement and `benchmarks'. \citet{Lilja2000} offers a good grounding in the area. \citet{Georges2007} explored the specific challenges of performance measurement of Java code running in a \emph{JVM} bytecode virtual machine while \citet{Gu2006} investigated the performance impact of differences between virtual machine implementations and \citet{Blackburn2004} discussed the \enquote{myths and realities} of performance and garbage collection. Such research was exclusively in the time domain, however, with no mention of energy use. More recently, research has included elements of energy-efficiency and power consumption \citep{Capra2012} \citep{Li2014b} and even some attempts at standardised energy benchmarks \citep{SPEC2008}. Despite this, the relationship between performance and energy use is complex, with some research validating the `folklore' that better performance implies better energy consumption \citep{Yuki2013}, while others discuss `tradeoffs' between the two measurements \citep{Joseph2001} and yet others point out that architecture choices can drastically alter the relationship before coding even begins \citep{Khomh2018}.

Researchers in this area generally agree that understanding energy use of software is vital in order to manage power consumption \citep{Snowdon2005}, but methodology for determining energy use varies widely. In addition to `folklore' that energy use can be predicted directly from performance, researchers have also tried to derive models relating energy use to many other measurable aspects of software. The aim of such models is usually to remove or reduce the need for expensive and time-consuming power measurements by replacing them with automatically calculable metrics. In the words of \citet{Povoa2013} \enquote{a model for estimating energy consumption should be simple, i.e., to consider only a subset composed of the most influential variables on energy consumption}. Such energy usage models fall roughly into two groups: \emph{dynamic} models and \emph{static} models.

Dynamic models base their energy usage predictions on observing various aspects of the software in operation. As an example, \citeauthor{Povoa2013} produced their dynamic model by running a software \enquote{monitoring agent} and reading 47 different values such as the amount of CPU time in user and system modes, memory usage, time spent reading and writing disk storage, number of packets sent and received over network interfaces and so on. They then ran some \enquote{synthetic workloads} (p.6) and used linear regression to produce an energy model which they then compared against measured overall energy usage for the same workloads. \citet{Chowdhury2015} observed the `system calls' by which applications make use of operating system features and also used linear regression to produce an energy model. \citet{Stoico2023} used layered queuing networks (LQN) to produce an energy model based on CPU and disk performance while processing images.

Static models base their energy usage predictions on analysis of the software and its environment without running the code.  \citep{Ibrahim2011} produced an energy model based on examining the machine instructions generated when software was compiled. \citet{Stier2015} produced an energy model based on the characteristics of system architectures. \citet{Ardito2018} measured the energy usage of a Rapberry Pi when idle and when running software designed to fully utilise each specific hardware feature, then used this data to infer energy usage of an application from the use of these features in the code. \citet{Hao2013} took the similar approach of generating a software environment energy profile (SEEP) for the target device and then used that to annotate individual lines of source code with predicted energy usage values.

The kinds of models produced by the above, however, are rarely generalisable beyond their experimental context \citep{Colmant2018}. Derived regression models and rules of thumb are specific to the combination of hardware, software, data and test scenarios which were evaluated. Static analysis models take no account of time, data variations or external input when the software will be executed.

The remaining way to obtain information about the energy usage of software is to measure it. Research in the literature has used a range of measurement techniques including:

\begin{itemize}
    \item Software modification \citep{Seo2008} \citep{Do2009} \citep{Sabovic2020}
    \item System emulation \citep{Sinha2001} \citep{Gurumurthi2002} \citep{Wilke2013}
    \item Power logging circuitry within the computer hardware \citep{Dutta2008} \citep{Kansal2008} \citep{Noureddine2012a}
    \item General-purpose lab equipment \citep{Flinn1999} \citep{Farkas2000} \citep{Ge2009} \citep{Ardito2018}
    \item Consumer energy meters \citep{Kaup2014} \citep{Kaup2018} \citep{Bekaroo2016}
    \item Battery simulation \citep{Zhou2013a} \citep{Naderiparizi2016}
    \item Custom power-measurement electronics \citep{Jiang2007} \citep{Stathopoulos2008} \citep{Andersen2009} \citep{Astudillo-Salinas2016}
\end{itemize}

Techniques which rely on modification of the software to be evaluated (sometimes also called \emph{instrumentation}) may not be suitable for evaluation of `black box' components and also raise questions about the validity of evaluating something which differs from the original software. Simulation techniques require powerful systems to run the simulation, and also require trust that the simulation is representative of the system being tested. The use of internal power logging circuitry relies on the presence of the specialist circuitry, so is only suitable for testing with specific hardware. In many cases such circuitry only measures power consumption of certain hardware within the system, typically the CPU and memory \citep{IntelCorporation2019}, and does not measure energy used by other devices such as storage drives or additional hardware for graphics, network communication or AI acceleration. Professional lab equipment is expensive and uncommon in commercial settings. For example, \citet{Dzhagaryan2016} used a National Instruments PXIe-6361 Data Acquisition Device in a National Instruments chassis at a total cost of around \$5500 while \citet{Manotas2014} and \citet{Ardito2018} used National Instruments USB data acquisition devices costing roughly \$2000 each. \citet{Rice2010}, \citet{Povoa2013}, and \citet{Milosevic2013} used similarly expensive equipment. Consumer energy meters have the advantage that they measure full system power and are cheaper than professional lab equipment, but often have limited accuracy and sample rate  \citep{Hindle2012a}, and some also require manual triggering or reading of values, which limits their use in automated measurements.

\citet{Dezfouli2018} analysed power measurement approaches from the literature and rejected all of the above as well as any custom electronics which they considered to be `complex'. The authors selected instead a solution using an low-cost INA219 power measurement integrated circuit \citep{TexasInstruments2015} controlled by a widely-available Raspberry Pi single-board computer \citep{RaspberryPi}. \citet{Hindle2012} initially used a consumer `Watts Up Pro' energy meter but, following issues with accuracy and resolution, also moved to a measurement solution based on the INA219 and a Raspberry Pi \citep{Hindle2014}, as did \citet{Chowdhury2015}. The INA219 device requires an external load resistor and can only measure current on the `high-side' of a power circuit. Texas Instruments also provide a more flexible device, INA260, which includes the load resistor and can measure both high- and low-side current \citep{TexasInstruments2016}. A circuit board containing an INA260 and associated circuitry can be bought for around \$10 \citep{AdafruitINA260}.

\subsection{Related Methodology}
\label{literature:related methods}

Despite the issues with general-purpose energy models discussed above, energy measurement can still be used for energy usage \emph{comparisons}. In this approach, most of the variables which limit the applicability of energy models are controlled. Energy measurements for different software are run on the same hardware and system infrastructure and using identical test scenarios with identical data and other input. This leaves the software as the key variable, implying that any differences in measured energy use are due to differences in the software. \citet{Bunse2013} used this approach to measure the impact of different \emph{design patterns} \citep{Fowler1999} on a software application. \citet{Zhang2014a} compared multiple versions of a software application to determine changes in energy use as the applications evolved. \citet{Pereira2021} compared implementations of a collection of computer benchmarks in different programming languages to investigate the languages' energy-efficiency. 

In practice, it is impossible to run the test scenarios for two different software options on the same hardware at the same time. The comparison researchers cited above all opted to control the hardware and configuration but run experiments at different times. Computer systems contain internal processes which vary with time and changing environmental conditions such as temperature can also be a factor, so there will always be some variability in the results. This variability is typically mitigated by taking multiple measurements and averaging \citep{Zhang2014a} \citep{Pereira2021}.

The majority of such comparison literature evaluates energy usage of software for single-user desktop or mobile platforms rather than the large-scale services which predominantly consume energy in datacenters.

\section{Research Gap}
\label{literature:gap}

The focus of this research is on the sustainability of the software used in large-scale connected ICT systems. The literature analysis above suggests a research gap in the area of energy sustainability of server applications and components. More specifically, an exploration of ways to reduce the energy usage of web systems by comparing and selecting software applications or components for energy-efficiency.

This research gap is still too broad for a single PhD, however. The following sections clarify the scope of this research.

\subsection{Exclusions From Scope}

\subsubsection{Computing \emph{For} Sustainability}
\label{scope:for sustainability}

The area of computing sustainability which seems to have received the widest coverage in literature is what \citet{Penzenstadler2013} refers to as `\emph{for} sustainability' (see also \autoref{section:terminology}). This is a broad area which can potentially address any of the UN Sustainability Goals, and which is characterised by the use of computer technology to achieve external aims. A typical example, picked largely at random, is \citet{Gwaka2022} which investigates the potential of digital platforms to revitalise a livestock system in rural Zimbabwe. However, research in this category often has a significant oversight. It is common in research for sustainability to treat the computing resources required to investigate or address an issue as effectively free and without significant sustainability impact. This attitude is endemic in computing research \emph{for} sustainability and is not to be taken as a specific criticism of \citeauthor{Gwaka2022}. While most research in this area is completely out of scope for this dissertation, there is an aspect of this kind of research which needs further consideration as it calls into question the sharp distinction between \citeauthor{Penzenstadler2013}'s two categories. This grey area is software which is applied to improve the sustainability \emph{of} ICT systems or the infrastructure on which the ICT systems depend. Examples of this area are discussed in \citet{Verdecchia2022a} and to some degree in all the experimental literature included in \autoref{literature:methods}. The software systems developed later in this dissertation also sit in this grey area.

\subsubsection{Sustainability \emph{Of} Computing}
\label{scope:sustainability of}

The second category mentioned in \citet{Penzenstadler2013} is the sustainability of the computing systems themselves. The research in this dissertation sits within this category. However, this category is still a broad area. In order to concentrate on the aspects of energy usage due to the operation of software, several other areas have been ruled out of scope for this research.

\paragraph{Sustainability of computing hardware and infrastructure}

Although it is the computing hardware and datacenter infrastructure which uses energy for its operation, and the physical constituents of such systems which enact the environmental impact, there is other research addressing these issues. The main focus of this research, however, is on the software systems which control the hardware and drive data through the communications networks.

\paragraph{Client-side and Network Software}

Software exists everywhere on the internet. Software systems can be classified into groups based on the role they play in its operation. Note that these groups are only rough, as some devices or systems incorporate aspects of multiple groups.
\begin{itemize}
    \item Single-user `client' systems such as phones, tablets, laptops and other computers, televisions, interactive signage etc.
    \item Sensors, data input devices, and other Internet of Things (IOT) `edge' devices.
    \item Network systems such as routers and switches, access points, network storage and caching devices.
    \item Service systems such as web servers, application servers and database servers as well as the shared applications which use them.
\end{itemize}

The energy impact of all these systems is important, but this research will concentrate on the energy impact of service systems. Energy management is already a high priority in battery-powered devices such as phones, tablets and some IOT devices. Single-user systems such as phones, tablets, and desktop and laptop computers are not subject to the same multiplication factors as multi-user web-facing systems. Network systems and edge devices are generally included in the power management of the internet infrastructure, which has already been de-scoped from this research. That leaves service systems which fit the criteria for systems which are in continual use by multiple concurrent users and therefore offer large potential gains from a reduction in energy use.

The distinction between different types of service systems is less clear, with many Web-facing systems operating as some combination of web servers, application servers and database servers as well as managing storage and internal communication and executing application-specific software. This research concentrates on server systems which contribute in some way to high-volume public web traffic and datacenter energy use.

Note that although other forms of software are not directly investigated in this research, some of the outcomes of this research may also be applicable to those kinds of software.

\paragraph{Operating systems and virtual machine systems}

Operating systems and virtual machine systems are software constructs, but share some of the characteristics of both infrastructure and applications. As with network software, some aspects of this research may also apply to these kinds of systems, but such infrastructural software is not the primary scope of this research.

\paragraph{Sustainability of software development tools and processes}

As discussed in \autoref{section:context development}, the practice of software development makes use of a lot of software itself. This kind of software follows the general principles of all software. Development tools are themselves created with development tools. They make use of libraries and components and embody the decisions made during their creation and maintenance. The operation of software development tools itself uses energy \citep{Zaidman2024}. However, \citet{Wahler2024} wrote \enquote{We conclude that the sustainability of the operations phase (in particular, the sustainability of the software product) needs to be considered together with the sustainability of the development process to see the larger picture}. The scale of operation of development tools is typically much smaller than that of internet applications. This research concentrates on the kinds of software which are used by millions of users every day and drive the major energy use of datacenters and communication infrastructure.

\paragraph{Theoretical efficiency of algorithms}

Potentially the oldest field of research related to software energy usage is the study of the efficiency of algorithms. Algorithm efficiency is commonly expressed using \emph{Big `O'} notation such as $O(n\log{}n)$. It is well understood that a sorting algorithm categorised as $O(n\log n)$ will typically perform more efficiently than one categorised as $O(n^2)$, for example. This is a valid theoretical field of study, but for many working software developers it is only of peripheral interest, as the algorithms typically studied in this way have already been coded into components, libraries, programming languages, and other development tools. 

Most developers never need to make design decisions at this level, but there is a hidden catch to this layer of abstraction. In order to use libraries and language features, a developer needs a degree of faith in the underlying implementation choices. When using, for example, a sort function from a library, the developer either needs to trust that the implemented algorithm is suitable for the intended use, or perform some extra steps of selection, configuration, or performance testing. In many real-world cases the pressure of commercial development means that the faith approach is the most attractive. This research is not directly concerned with the efficiency of specific algorithms or data structures.

Although the theoretical analysis of algorithms is out of scope for this research, there is an important lesson to take from such studies. The amount of work done by software depends on the size and complexity of its input data. An approach which is `better' for small or similar input data may be `worse' for large or varied input data or vice versa. This lesson is sometimes overlooked when attempting to evaluate or compare software solutions, and is explored in more detail in \autoref{comp:experimental process}.

\subsection{Constraints of Scope}

\subsubsection{Static and Dynamic Websites}

The original aim of the web was for the storage and sharing of documents \citep{Berners-Lee1992}. In some sense this is still true, as each GET request of the HTTP protocol transfers a document from a server to a client \citep{Berners-Lee1996} \citep{rfc2616}. It is then up to the client software to render that document appropriately for whoever or whatever has requested it. There is, however, an important distinction in where the document comes from.

In a \emph{static} website, all documents, images and other resources are created ahead of time. When a GET request is received, the task of the server is to locate the appropriate resource and send it to the client. In most cases this is a relatively simple process, involving little more than decoding the requested URL into a file path and replying with the contents of the file at that location, or an error if nothing is found. This process is complicated a little by the need to also return an appropriate \emph{Content-Type} header so the client software knows what to do with the data, but this is usually a simple look-up based on part of the filename.

In a \emph{dynamic} website, some or all of the documents do not exist as files in a file system, but are created when the request is received. Dynamic documents can be created in a wide range of ways, ranging from simple modifications or concatenations of existing files to programmatic approaches using complex calculations, data from databases and even requests to other systems. This wide range of possibilities makes it hard to reason about dynamic websites as a single concept, except to say that extra complexity can require both more time and more energy to serve.

This research includes a comparison of the energy usage of static and dynamic websites serving the same data.

\subsubsection{Page Templating Systems}

As discussed above, there are many ways of dynamically generating a document to respond to a server request. This research will concentrate on one popular method - \emph{templating}. This process uses a single template document to construct many different response documents. A template consists of two kinds of data - fixed parts, which will be the same for all generated documents, and variable parts, which will differ based on data and values which are specific to that generated document. For example, templating could be used on a shopping website such as Amazon.com. Each product page has the same basic structure, but the product images, descriptions, prices and so on are specific to each product page. When the page for a specific product is requested from the server, the data for that product is fetched from a database and used to populate the variable parts of the template, and then the combined result is returned as the response.

\subsubsection{The Java Programming Language}

There are a large number of programming languages, and testing a meaningful sample of template engines in all of them is not feasible in a single research project. Instead, the Java language was selected. Java is a popular language, especially for for server-side programming \citep{Tiobe2018} and offers a non-trivial number of alternative templating systems to choose from.

\subsection{Scope Summary}
\label{scope:summary}

This research concentrates on ways to reduce the energy usage of web systems by selecting or replacing software applications or components related to static and dynamic websites and page templating systems built using the Java programming language. In particular, this research explores performance and measured whole-system energy usage comparisons between server applications and components under a range of different usage patterns. While other related aspects of sustainability and environmental impact are occasionally discussed, they are not the core focus of the research.

\section{Research Objectives}
\label{section:research objectives}

The above scope definition leads to several related research objectives.

\paragraph{Explore the differences in performance of example software components}

One potential approach to reducing the impact of computing systems is to replace subsystems with ones which consume less energy and thus contribute less greenhouse gasses to the environment. To determine the potential feasibility and benefits of component substitution as an energy-reduction strategy requires information about the characteristics of software components. One such characteristic is performance. The selection of components with better performance can allow systems to run with fewer, or less powerful, computer platforms.

The feasibility of comparing the performance of individual software components is addressed in \autoref{chapter:performance}. A representative category of software component (web template engines) was selected and the execution speed of a range of components was compared in \autoref{section:fs1}. This feasibility study was followed by a deeper exploration of the performance characteristics of different features provided by template engine components under varying loads in \autoref{section:fs2}.

\paragraph{Compare the energy use of software during operation}

Software component performance is not the only, or even the most direct, measure of the possible energy saving from substituting software components. Measurement and comparison of the energy usage of software during operation can potentially provide a more explicit indication of relative energy usage of components and systems in live use.

The development of a low-cost stand-alone apparatus to compare software energy usage is described in \autoref{chapter:testrig}. The apparatus was evaluated by comparing the energy usage of a selection of popular web server applications.

\paragraph{Explore substitution of incompatible components using drivers and template generation}

In general, software components are not directly interchangeable. The template engine components investigated in \autoref{chapter:performance} differ in two key areas: the software application programming interface (API) provided by the components, and the data formats used to describe the templates they use. An intermediate data format and software tools to generate appropriate data files for a range of template engines is developed in \autoref{chapter:intermediate}.

To assist substitution of such template engine components, a collection of software frameworks, data formats, and tools were developed. This software was used in \autoref{chapter:comp energy} to enable more realistic testing of template engine energy usage in conjunction with the comparison apparatus described in \autoref{chapter:testrig}.
