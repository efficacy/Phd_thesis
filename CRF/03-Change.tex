\chapter{What Can Developers Change?}
\label{chapter:change}

\section{Forces Which Affect Software Development}
\label{section:forces which affect software development}

Software development is not done in a vacuum. Developers produce software systems in the context of existing software and hardware choices and subject to conflicting forces.

\subsection{Requirements and Expectations}
The first and most obvious force on development is the presence of requirements and the expectation from stakeholders that these requirements will be met. The classic software life cycle was based on commercial software development projects, and usually presumes the presence of customers and requirements, often decided before the design and programming phase of the product begins. While requirements are often present in such situations, there is also a considerable amount of software development which happens in the absence of requirements in the traditional sense. Personal and hobby projects rarely have requirements beyond "scratching the itch" \todo{citation} of a particular software developer or small team, and academic software is often more exploratory in nature an defined by its results rather than its specification. Software developed using one of the many agile processes \todo{citation} usually has requirements, although these requirements and priorities are decided during the development process rather than before it starts.

In situations where requirements are present they can have varying degrees of rigidity, from precise specifications which must be followed exactly to loose guidance subject to interpretation. In all such cases, however, the presence of requirements, and the accompanying expectations of customers and other stakeholders exert a force on the software to conform to the requirements and to avoid chouces which might prevent those requirements being met. That's not to say that software always meets its requirements, of course, but the pressure is there nonetheless.

\subsection{Timescales}
Along with the pressure of requirements comes the pressure of timescales. These come in many forms from single hard deadlines, to a sequence of deliverables or progress demonstrations with negotiable dates. The pressure of timescales can be more subtle and insidious than that of requirements, as it encourages the making of quick decisions and provides an obvious penalty to taking too long to research or come to a conclusion on a choice. This in turn can lead to choices being made without enough information, an outcome which is especially likely in situations where that information is both lengthy and expensive to obtain.

\subsection{Development Costs}
Cost is an issue in almost all software development projects, with the main exception being personal hobby projects which are usually limited more by time than money. Just as with timescales, the pressure to keep development costs low can also act to encourage quick (and cheap) decision-making, although a more thorough investigation is sometimes possible if the predicted cost of an incorrect decision outweighs the cost of the research.

\subsection{Available Skills}
However bold the aims of a software project, there is a hard limit imposed by the skills, experience, knowledge and capabilities of the people involved. To some extent such skills can be increased during a project but this will need to be traded for time (in the case of building the skills of people already attached to the project), cost (in the case of bringing in extra people who already have the desired skills), or both.

The knowledge and experience of team members significantly affects the decisions made during design and development of a software system, both in terms of implementing requirements directly, and in terms of selecting third-party components to import into the product. Lack of experience among the team can also lead to decisions which negatively impact cost or timescales, and in turn increase the pressure to make decisions quickly and cheaply.

\subsection{Ethics}
Depending on the nature of the application or system being developed, ethical issues may have a different impact on the choices being made during the development process. Ethics in computer science is largely concerned with the uses or impact of \emph{what} is produced rather than \emph{how} it is produced. For example, software to control medical equipment or weapons might be subject to more ethical scrutiny than a calculator or a solitaire game. Software developers are not often involved in the decisions about how a software product will be used, but still bear an ethical responsibility to consider those decisions, particularly those decisions which affect the correct functioning of vital or potentially deadly equipment.

\subsection{The Dilemma of Sustainability}
While all the pressures mentioned above are well understood and often discussed in the context of software design and development, the dimension of sustainability is much less frequently acknowledged \todo{citation?}. Commercial software mostly exists in a money-focused world where income is balanced against outgoings. If the environmental impact of a system is considered it is usually though the lens of cost - the cost of energy, the cost of adding or replacing hardware, the cost of infrastructure, and so on. Unfortunately, cost is a poor proxy for sustainability impact \todo{citation} and is confused even more by techniques such as offsetting and "carbon credits" \todo{citation}.

The issue of sustainability is a dilemma because, while the corporate forces affecting decisions largely overlook sustainability, that does not imply that the individual people involved in making and implementing decisions are oblivious or insensitive. The same person who might act to reduce waste and greenhouse gas emissions at home, or publicly fight for gender equality and social justice finds themself in a position at work where sustainability is often seidelined or trumped by other factors which are more easily mapped to financial gain or loss.

\section{Developer Choices}
\label{section:developer choices}

The software development process can be viewed as a sequence of choices. Some choices are large and set the scene for many others. Some choices are relatively minor and self-contained. This section explores some of the areas in which such choices are made.

\subsection{Solution Architecture}

In most software projects, the biggest and most significant decisions are usually in the architecture of the solution. This includes choices such as whether to build software which runs on a client system or a central server, how to deal with the expected number of users and quantity of data, where to store information, and so on. Like so many things in software development, there is no clear and universally accepted definition of the what constitutes an architectural decision rather than one of the many other kinds of decisions. On the whole, if a decision affects the overall structure of the software system and therefore needs to be made early in the development process, it is usually considered as an architectural decision.

\subsection{Programming Languages and Tools}

There is a class of decisions, however, which sits somewhere between architecture and general development and can cause demarcation problems among teams. The choice of programming languages and other development tools. Such decisions do not directly affect the structure and capabilities of the final software system, so it could be argued that they fall outside the remit of architecture. On the other hand, they are major decisions which are not easy t o change once a significant amount of development work has been done, so it could be argued that they need to be included in the architectural decisions made at the start of a project. \todo{citation}

There are ways around this issue, even if not all teams take advantage of them. In some software development situations the available tools and programming languages have already been predetermined, either by a commercial decision out of the hands of anyone in the software development process, or by company culture, an existing body of skills and knowledge, or a history of previous software products on which the new one will be based. In other cases it is possible for an architectural decision to be made which pushes the decisions on tools and programming languages "down" to smaller development teams, each responsible for different parts of the overall system. One technique to enable this is "microservices", in which the architecture of a system is defined as a collection of collaborating smaller subsystems, each of which communicates only though a predefined interface, allowing development teams freedom to use whatever development tools and approaches are most suitable for that subsystem \todo{citation}.

\subsection{Testing and Documentation}

In many projects, software developers are also responsible for some aspects of testing and documenting the code which they produce. Testing is itself a complex field \todo{citation} which is largely beyond the scope of this research, but there are some key choices which software developers always need to make during the development process.

\paragraph{\emph{When} to test}

The first of these key choices is \emph{when} to test the code. In the classic software development life cycle (SDLC) model, testing is usually shown towards the end of the development phase \todo{citation}. This may seem reasonable at first glance but it is at best an oversimplification and at worst a dangerous holdover from obsolete development practices. In the 21st Century the great majority of software is developed interactively, with software developers checking their work as they go. This checking may be manual and informal such as repeatedly re-generating a web page while tweaking with the code until it looks right, or it may be more formal and involve the creation of "unit tests" (also known as "developer tests") \todo{citation} which are run after every change to make sure that everything is still working as expected.

Testing during development is so much a part of the modern development process that it is tacitly assumed by most developers \todo{citation?} but there is a form of developer testing which provokes more controversy. Test Driven Development (TDD) \todo{cite Beck} is a form of testing which is started before any application code is even written. This may seem counter-intuitive, as at that point there is nothing to test, but it is valued and used by many experienced software developers \todo{cite a study?}. In TDD a test is written as part of the design process for a new feature or area of the code. The creation of the test serves as a tool to reason about the new feature, and also provides a kind of "executable documentation" of how it should be used. A test for a new feature is expected to fail, because the feature has not yet been implemented, and the job of the developer them becomes writing the application code to make the test pass. TDD has many practical and psychological benefits, discussion of which is beyond the scope of this research, but can be found in the literature \todo{citations}.

The key point is that a software developer continually faces choices about whether to test their code before, during, or after development.

\paragraph{\emph{What} to test}

Even having decided \emph{when} to test, there are also choices about \emph{what} to test. At one end of the scale it's probably too much work for too little return to try and test every line of code, but at the other end it would slow down development too much to test every interaction of a whole system during development. Testing too little can result in delivering code with unknown faults or limitations, whereas testing too much can greatly increase the duration and cost of the development process. Each developer has a responsibility for deciding which parts of the system need testing, and how often.

\paragraph{Documentation}

Along with the many decisions about the architecture, tools, and testing needed to create a software product, developers need to make decisions about documentation. Software documentation exists for multiple purposes and audiences. The most urgent of these audiences is the developer. Just as with any other creative endeavour, software developers make notes, plans, sketches, reminders, and whatever other forms of documentation are needed to make sure that the software being produced is what was intended. The next most urgent form of documentation is for other software developers working with the same code. This may include some of the personal design notes and things, but will also include after-the-fact documentation such as code comments and other annotations which are intended to make it easier to understand the code which has been written. Beyond the immediate team there is documentation about interfaces, formats and protocols for other developers to use for communicating between different parts of the system. Finally there is the documentation provided for anyone who needs to manage or use the final system.

\subsection{"Green field" or Code Reuse?}

If you read most books on software development \todo{some citations} it's easy to assume that the next step after the architectural decisions is to decide on the algorithms and data structures which will form the final software, and then start creating code. While there is eventually an aspect of this kind of programming, it is hardly ever as simple as that. Real software in a high-pressure environment such as commercial development rarely starts from a completely blank page but has to fit in with other parts of the system and conform to the choices which have already been made. Even so-called "green field" software development, creating something new rather than adding features or fixes to existing systems, almost always starts by finding existing code which does something roughly similar to work from \todo{citation}.

When starting a software project in this way, or when adding existing code to a software project at any other point in the process, the existing code can be used in one of two ways: "White Box" (also known as "Copy and Paste") - in which the external code is added directly into the project and then modified to suit, and "Black Box" - in which the external code is added to the project as a library, component, or module and used as-is. This decision of whether, and if so how, to bring third-party code into a system is made many times during a project, and the context of each choice will determine the outcome. A typical software system will contain a mixture of both black box and white box re-use along with code created specially for this application.

White box code re-use is the most flexible, as the software developers importing the code have the freedom to include all or only part of the external software, and also to edit or modify it as needed for its new use. White box code re-use also has its problems, though. Importing partial code or modifying the code which has been imported can introduce problems and security issues which were avoided by the original. White box code reuse also provides the continual temptation to add further copies of the imported code throughout the new project. This not only increases the size of the codebase but greatly complicates code maintenance if the imported code ever needs to be modified or updated.

Black box code reuse does not offer the opportunity to import partial or modified versions of a component, but does ensure that the imported component contains its full functionality. As such an imported component is a "black box" it typically only needs to be imported once to the codebase for it to be available wherever it is needed, which can help reduce the size of the overall solution. This form of code re-use enables much easier updates if an improved version of the component becomes available. While the code for a black box component may be available for inspection, it cannot usually be modified, so if specific features, performance or ways of operating are required there is very little scope for adding them. In such cases the main option is to look for an alternative component which does have the desired characteristics.

\subsection{Component Selection and Evaluation}

As discussed above \todo{section link}, the choice of whether and how to bring third-party code into a system will be made many times in a typical project, but that should not be taken to imply that the choice or the process is easy. Most programming  languages, tools, libraries, and software components in modern software development are available free of charge. A large proportion of libraries and components are also "open source" \todo{citation} with the code available for free online, making them suitable for both white-box and black-box re-use. The spread of open source software has changed software development in a range of ways \todo{citation}. Many of these changes have been positive, such as a reduction of the cost and complexity of sharing and re-using existing code \todo{citation}, but the adoption of open source has not been universally beneficial.

Commercial software, buy its nature, exists to earn money, and commonly some of that income is spent on marketing, advertising, and competition. Free software has no such income stream (although there are other ways which developers of free software can earn money from their efforts \todo{citation}) and this is often reflected in the quality of documentation and marketing materials. In some cases open source software provides no supporting documentation at all other than the code itself. This lack of information has led to a confusing, cluttered, landscape of potential software components for a software developer to choose from. As creating and sharing a new software component is so simple, there is usually an overwhelming number of options to address any common problem. Where documentation does exist it might be out of date, incomplete, contain unverified claims, or even conflict with itself \todo{find some examples}.

Even in cases where the documentation of what a component can do, and how to use it, are of better quality, there is an extra layer of information which can be much harder to find. This "hidden" information includes such things as the performance of the component, any bugs or security problems, and any other components which it uses. Most significantly for this research, it turns out to be extremely hard to find details of the energy consumption of a component \todo{citation}. The lack of detailed information about performance, energy usage and other important aspects of a software component is a sharp contrast to components in other fields of engineering. In mechanical engineering, precise tolerances and load abilities are vital, and in electronic engineering the manufacturer of every component provides an extremely detailed data sheet giving the physical and electronic characteristics of every aspect of the component. \todo{examnples} A software developer facing a deadline and making decisions about whether or not to re-use an existing software component is forced to choose between using a component without knowing its characteristics or spend a lot of time and effort on trying to understand and evaluate every potential component.

\subsection{Team Customs, Culture and Style}

All the decisions available to a software developer exist in the context of a product, and probably a project, but also usually in the context of the development team. There are exceptions, of course, such as single-person development and hobby projects, but most software is developed in teams. A team is more than just a collection of people with different roles, it is also a body of knowledge, shared attitudes, and traditions. These customs and culture inform decisions made within that team, and choosing an option which goes against the prevailing culture can be much more difficult to do than following the common approach. Most software developers are not free to choose any programming language, library, component, framework, or any other aspect of coding style. Many such choices are made at a team, or even corporate, level.

Part of this body of knowledge is an implicit understanding of the roles and responsibilities within the team and the organisation. In some teams all major decisions (however that may be defined) are only accepted if made by a particular senior or lead developer, and it becomes the responsibility of less senior staff to petition the lead developer for an answer. In other situations, decision-making is more egalitarian, but may still be subject to rules such as "code ownership" \todo{citation} or a legacy of previous decisions which may not be challenged. Not everyone in a team is trusted to make every kind of decision.

\subsection{Bigger Decisions}

There is also another context which surrounds and informs all software development choices and decisions - the point of doing it. This may sometimes be codified as "requirements" ahead of development \todo{citation}, or it may evolve as an understanding as the problem and solution domains are explored, but it has to exist in some form in order for any decisions to make sense. There are some key decisions which exist in this space, and which can affect the whole of the software development process. For example, does the solution to this problem require software development at all, or is there a viable non-software alternative? Similarly, it is also important to decide if the product being developed is actually needed , or whether the potential disadvantages and costs outweigh the benefits \citep{Linders2023}.

\section{Make or ``Buy''?}
\label{section:make or buy}

Not all software is written "in house". Many software applications have already been written, and some of them may be appropriate for the task in hand. The decision on whether to create something new, or alternatively to use an existing product, is a business decision traditionally known as "Make or Buy". In physical manufacturing this name makes more sense, as the choice is usually between a costly design/manufacturing process and negotiating with a supplier to source source and purchase something equivalent to see which option is more cost-effective. In software development, however, the decision is different, but just as difficult. Software is infinitely flexible, so determining whether an existing product is equivalent (or at least \emph{capable} of being equivalent) is a lengthy, complex and expensive process in itself. On the other hand, there is a lot of software which is available for free (in monetary terms, at least), so the decision involves not just deciding which option to choose, but also deciding how much time and money to spend on the decision-making process. \todo{citation} In software development, the "buy" aspect of "make or buy" is not a simple purchase transaction. This can cause problems for organisations with a purchasing policy originally conceived as a way to manage costs, as standard approaches such as selecting the lowest price are inapplicable.

Just as physical manufacturing can make use of existing components and assemblies, software development can incorporate existing code into a new product. Software written using high-level languages can make use of language features and the standard libraries which are bundled with the language compiler or interpreter. Even the lowest-level code for small embedded devices is rarely written completely from scratch. In addition to built-in library code, most programming language ecosystems have a rich and diverse selection of additional modules, components, and libraries. Beyond that, the world of open source software provides an even broader selection of additional prewritten code to choose from. There are, of course, also some commercial libraries and modules which require payment to buy or licence.

It might seem obvious that if the "buy" option is monetarily free, then the choice between "make" or "buy" should always be "buy". After all, programmers, and all the other software development roles mentioned above, are expensive, so a free option should be automatically better. Unfortunately, such a view is naive. While there may be no monetary cost associated with the use of a third-party software component, there are hidden costs which may ultimately outstrip the cost of making such a component in-house. Typical issues faced when attempting to include an external component in a software product include:

\begin{itemize}
    \item The component does not include all the required features
    \item The component has faults which would impair the product
    \item The component documentation is incomplete or misleading
    \item The component has security problems
    \item The component depends on other components which conflict with the product or with other components used by the product
    \item The component does not exhibit the required performance
\end{itemize}

Resolving any of these kinds of issues could easily cost more than writing the required code from scratch.

If a third-party component were to exist which was entirely suitable for, and easy to integrate with, the product, then the decision to "buy" would be a good one. However, even this is more complicated than it seems on the surface. Most free components, being built by one-person teams as described above, lack the kind of detailed documentation which is needed to make an informed decision as to whether the component is suitable or not. In economics terms this means that although the \emph{purchase cost} of the component is zero, the total \emph{transaction cost} \citep{OECD2003} is considerably more than that. The particular difficulty when it comes to choosing between make or "buy", or choosing between options to "buy" the actual transaction cost of each option is unknown, and even the process of determining the transaction costs has a transaction cost of its own, and that is also unknown.

In many cases the organisation simply washes its hands of such choices, leaving the decisions to technical staff who are expected to be able to make an appropriate choice. Unfortunately, the process of evaluating potential components to "buy" takes time away from other work, and the resources to make an optimal choice are rarely available. This evaluation and selection process will be discussed in more detail in the next section.
